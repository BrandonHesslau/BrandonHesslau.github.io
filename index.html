<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">


	<title>My Portfolio</title>
	<link rel="stylesheet" href="style.css">
    <link rel="stylesheet" type="text/css" href="slick/slick.css"/>
    <link rel="stylesheet" type="text/css" href="slick/slick-theme.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.css"  />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />

</head>
<body>
	<header>
        <img src="profile.jpg" alt="Your Name">
        <div>
            <h1>BRANDON HESSLAU</h1>
            <h2>Welcome! I'm a Chicago based Game &amp; Software Engineer</h2>
        </div>
       
    </header>

    <div class="buttons-container">
        <a class="button-twitter" href="https://twitter.com/bhesslau" target="_blank"><i class="fab fa-twitter"></i></a>
        <a class="button-github" href="https://github.com/bhesslau" target="_blank"><i class="fab fa-github"></i></a>
    </div>
    <hr class="short-line">

    <nav>
		<a href="index.html">Portfolio</a>
        <a href="aboutMe.html">About Me</a>
		<a href="contact.html">Contact &amp; CV</a>
	</nav>
	<main>

        <h2 style="text-align: center; font-size: 2rem ;  margin-bottom: 1rem; color: #fff;">Portfolio</h2>
      
		<section class="project">
			<div class="project-info">
                <div class="title-year-container">
                    <h2>Buddy Simulator 1984</h2>
                    <h3 class="year">2019-2021</h3>
                  </div>
                <h3><b>Role:</b> <i>Lead Game Engineer & Concept Creator</i></h3>
				<h3><b>Skills/Software Used:</b> <i>Unity, C#, Git</i></h3>
                <h3><b>Relased for:</b> <i>PC, Nintendo Switch, PlayStation, Xbox</i></h3>

			</div>
			<div class="details">

                <p><b>Buddy Simulator 1984</b> is a retro, psychological horror game developed by Not a Sailor Studios.
                    It was originally released for PC in February 2021 and received popularity from a one-shot demo released previously. It has since received over 100,000 downloads and has been published by Feardemic for Nintendo Switch, PlayStation, and Xbox. It features a narrative involving an AI best friend that emotionally attaches to the player, and continues to make new games to keep the player occupied which leads down a entertainingly dark path. It also features dynamic gameplay from text adventures to 3D FPS mechanics, immersive dialogue choices, 4th wall breaking moments, multiple endings, and turn-based combat.</p>
                
                    <iframe width="100%" height="100%" src="https://www.youtube.com/embed/matlaLDM-iM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen style="height: 400px;"></iframe>

                <div class="slideshow">
                  <!-- Add your trailer and/or screenshots here -->
                  <img src="https://cdn.akamai.steamstatic.com/steam/apps/1269950/ss_3fc0fe2deff923d2b011a2809c59341cd36e7fd5.600x338.jpg" alt="Image 2" />
                  <img src="https://cdn.akamai.steamstatic.com/steam/apps/1269950/ss_9c06d6489ad6f788973b4afe8d33ad6214380d06.600x338.jpg" alt="Image 3" />
                  <img src="https://cdn.akamai.steamstatic.com/steam/apps/1269950/ss_c983a07316fbab778791df3c199c4f725494ac95.600x338.jpg" alt="Image 4" />
                  <img src="https://cdn.akamai.steamstatic.com/steam/apps/1269950/ss_7556a1041f8e4f16357e76de4838097e090884c9.600x338.jpg" alt="Image 5" />


                </div>

                <div class="project-links">
                    <h3><b>Project Links</b></h3>
                    <ul>
                     <li><a href="https://notasailorstudios.com/Buddy_Simulator_1984.html">Official Site</a></li>
                      <li><a href="https://store.steampowered.com/app/1269950/Buddy_Simulator_1984/" target="_blank">Steam</a></li>
                      <li><a href="https://notasailorstudios.itch.io/buddy-simulator-1984" target="_blank">Itch.io</a></li>

                      <!-- Add more links if necessary -->
                    </ul>
                  </div>

                <h3><b>Work Done</b></h3>

                <ul>
                <li>Led development of all gameplay systems, technical art, and optimization.</li>
                <li> Developed smooth player movement and intuitive interaction behavior for custom 2D, 2.5D, and 3D character controllers.</li>
                <li> Created dialogue branching systems and story-based decision tracking.</li>
                <li> Designed dynamic turn-based combat systems, featuring distinctive character move sets.</li>
                <li>Implemented framework for effortlessly saving and loading game states.</li>
                <li>Collaborated closely with team members to ensure seamless integration of various components and gameplay elements.</li>
                </ul>
                <div class="code-highlight">
                  <h3><b>Project Highlight:</b> Turn-Based Combat Moves</h3>
                  <p>The following code snippets demonstrate my process for designing the combat actors & systems for Buddy Simulator 1984.</p>
                    <div>
                        <div class="slide-content">
                            <div class="text">
                                <p>When starting this system, I knew I wanted it to be very abstract so I only had to worry about behavior specfic to each move. I wanted to be able to quickly create new move scripts by inheriting all of the information that would be shared among each move. 
                                For instance, I knew each move could have different types of inputs such as a single tap or a mash, and I didn't want to redefine this behavior evertime. So, I started by defining a <b>FriendlyEncounterMove</b> class which would be the base of all friendly combat moves throughout the game. <i>Note: The system for enemy moves works similary.</i></p>
                              </div>
                                <div class="code">
                              <pre><code class="language-csharp">

public class FriendlyEncounterMove : MonoBehaviour
{

    /*-------Example Behaviors from FriendlyEncounterMove.cs------*/

    // Initiates a button tap event with the given key code and hit time
    public void InitiateButtonTap(KeyCode key, float hitTime)
    {
        // Pause the animator
        _animator.speed = 0;
    
        // Play a block sound effect
        _audioSrc.PlayOneShot(EncounterController.currentEncounter.GetEncounterSoundManager().GetBlockSound());
    
        // Set the text of the button box to the key pressed (either the space key or a letter/number)
        if (key == KeyCode.Space)
            buttonBox.transform.GetChild(0).GetComponent<TextMesh>().text = "SPACE";
        else 
            buttonBox.transform.GetChild(0).GetComponent<TextMesh>().text = ((char)key).ToString().ToUpper();
    
        // Show the button box
        buttonBox.SetActive(true);
    
        // Set the tap time and key
        tapTime = hitTime;
        tapKey = key;
    }
    
    
    // Initiates a button mash event with the given key code and hit time
    public void InitiateButtonMash(KeyCode key, float hitTime)
    {
        // Set the text of the button box to the key pressed (either the space key or a letter/number)
        buttonBox.transform.GetChild(0).GetComponent<TextMesh>().text = ((char)key).ToString().ToUpper();
    
        // Show the button box and trigger the button mash animation
        buttonBox.SetActive(true);
        buttonBox.GetComponent<Animator>().SetBool("mash", true);
    
        // Set the tap time and key
        tapTime = hitTime;
        tapKey = key;
    }

}

                                </code></pre>
                            </div>

                          </div>                      
                        </div>
                      <div>
                        <div class="slide-content">
                            <div class="text">
                                <p>After all of the core functionality for a friendly combat move was defined, all of the combat moves I would create could be made fairly quickly without code reuse. As an example, here is a script for a character called Morton who performs kickflips with a skateboard. Everytime a successful button tap is met, his final damage increases. As you can see, the <i>InitiateButtonTap, Succeed, Fail, and Critical</i> are all overriden from the base FriendlyEncounterMove class. Building the combat system this way also allowed for much easier debugging later on.</i></p>
                              </div>
                                <div class="code">
                              <pre><code class="language-csharp">

public class Move_Morton_KickFlip : FriendlyEncounterMove
{

    // Initializes any variables at the start of the move
    public override void BeginMove()
    {
    }

    void Update()
    {
        // Call the base class's UpdateMove function to update the move state
        base.UpdateMove();
        if (skating)
            UpdateSkate();
    
    }

    void UpdateSkate(){

        // If the move state is 0, move the character towards the target position while facing left
        if (moveState == 0)
        {
            transform.position = Vector3.MoveTowards(transform.position, targetPos + Vector3.left*5.0f, Time.deltaTime * skateSpeed);
            // If the character has reached the target position, set the move state to 1 and set the target position for the jump
            if (transform.position.x <= targetPos.x)
            {
                moveState++;
                transform.position = new Vector3(transform.position.x, transform.position.y, currentEnemyTarget.transform.position.z);
                GetComponent<Animator>().SetTrigger("morton_walkr");
                targetPos = currentEnemyTarget.transform.position - currentEnemyTarget.transform.right * jump1Distance;

            }
        }
        //And so on...   
    }

    // Triggers the kickflip animation
    void WaitForKickFlip()
    {
        GetComponent<Animator>().SetTrigger("BeginKickFlip");
    }

    // Shows the kickflip button and initiates a button tap event with a random letter key, contained in base class
    void ShowKickFlipButton()
    {
        InitiateButtonTap((KeyCode)Random.Range(97, 123), DefaultTapTime);
    }

    void IncreaseKickMoveState()
    {
        moveState++;
    }

    // Executes the kickflip animation and increases final damage to perform
    void KickFlip()
    {

        // Play a kickflip sound effect based on the number of kickflips already executed
        if (kickflipCount == 0)
            PlaySound(kickflip1Snd);
        else if (kickflipCount == 1)
            PlaySound(kickflip2Snd);
        else if (kickflipCount == 2)
            PlaySound(kickflip3Snd);
        kickflipCount++;

        // Increase the base damage of the move and trigger the kickflip animation
        baseDamage += 5;
        GetComponent<Animator>().SetTrigger("KickFlip");

        // Spawn kickflip particles and destroy them after 0.4 seconds
        GameObject particles = Instantiate(kickParticles, particleParent);
        particles.transform.localPosition = Vector3.zero;
        particles.transform.localEulerAngles = new Vector3(90, 0, 0);
        Destroy(particles.gameObject, 0.4f);

        // Apply the "Dumb and Dizzy" modifier to the enemy with a 20% chance
        if (RollChance(20))
            currentEnemyTarget.GetComponent<ModifierController>().ApplyModifier(Modifier.MODIFIER.Dumb_And_Dizzy);

        //Shake the camera
        Camera.main.GetComponent<ObjectShaker>().InitiateShake(0.1f);
    }

    protected override void Succeed()
    {
        GetComponent<Animator>().speed = 1;
        KickFlip();
    }

    protected override void Fail()
    {
        GetComponent<Animator>().speed = 1;
        GetComponent<Animator>().SetTrigger("StopKickFlip");
        moveState++;
    }

    protected override void Critical()
    {
        Succeed();
    }

}

                     </code></pre>
                    </div>

                    
                    </div>

                    
                    <div class="text">
                        <p>Here is the final result recorded from a Combat Sandbox scene that I worked in during the development of the combat systems.</i></p>
                    </div>
                    <div class="video-container">

                    <video controls>
                        <source src="Video Clips/BuddySim_1.mp4" type="video/mp4">
                      </video> 
                    </div>
                    </div>
                </div>
              
			</div>

            
			<div class="overlay"></div>
			<div class="reveal"></div>
			<div class="line"></div>
		</section>
		<section class="project">
			<div class="project-info">
                <div class="title-year-container">
                    <h2>Mulligan</h2>
                    <h3 class="year">2021-2023</h3>
                  </div>
                <h3><b>Role:</b> <i>Lead Game Engineer</i></h3>
				<h3><b>Skills/Software Used:</b> <i>Unity, C#, Python, Photon, Git</i></h3>
			</div>
			<div class="details">

                <p><b>Mulligan</b> is a procedurally generated horror project developed by Not a Sailor Studios which features a unique assortment of AI-driven monsters to prevent you and your friends from leaving with your lives. Players will fight, loot, hide, and escape from certain death that awaits around every corner. Mulligan is currently an incomplete project.</p>
            
                <iframe width="100%" height="100%" src="https://www.youtube.com/embed/ovr2z-XeP1w" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen style="height: 400px;"></iframe>
                <iframe width="100%" height="100%" src="https://www.youtube.com/embed/Jsm8lL5pCnk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen style="height: 400px;"></iframe>


                <h3><b>Work Done</b></h3>
                <ul>
                <li>Led development of all gameplay systems, technical art, and optimization.</li>
                <li>Developed multi-threaded procedural level generation systems for interior and exterior world building.</li>
                <li>Designed innovative in-house room builder tool that integrated with the procedural generation systems.</li>
                <li>Created BT-based AI monster behavior that demonstrated clever techniques for hunting players, elevating the game's challenge and intensity.</li>
                 <li>Integrated networking frameworks with Photon.</li>
                 <li>Engineered custom player behavior with in-depth world interactions from hiding to searching.</li>
                </ul>
                <div class="code-highlight">
                  <h3><b>Project Highlight:</b> Procedural Level Generation</h3>
                  <p>The following demonstrates a brief overview of my procedural generation system.</p>
                    <div>
                        <div class="slide-content">
                            <div class="text">
                                <p>The goal of the proceural generator was the generate a dynamic tile-based building that felt natural. We weren't making a dungeon crawler where you were always inside. The world had to have interiors and exteriors. At the beginning of this project, I knew the level generation system was going to be the most difficult, which is why it was the first thing I tackled. Originally, I had built a procedural generation system that was fairly quick, but was definitely brute-forced. 
                                    It would behave well until you started to add many rooms to the structures. It would attempt to fit and rotate all of the room "blueprints" until it found a solution. Also, all of the walls were individual game objects which would cause some FPS issues if not used carefully. So instead, I eventually scrapped it and started fresh with a new idea that used multi-threading and recursive methods, as well as dynamically generated meshes.</p>
                              </div>
                              <div class="text">
                                <p>
                                The <i>structure</i> of my generator became as follows: A Building contains a set of Room Regions, and a Room Region contains a set of Rooms. This was so rooms could feel naturally placed. For instance, if I was generating a school, I could have a defined area where classrooms could spawn, as opposed to scattering them throughout the building.
                                This also made the placement process quicker. A Room Region is ultimately just a large block of space, and it's a lot easier to find optimal placement for fewer large spaces, then many small ones.
                                </p>
                              </div>
                              <div class="text">
                                <p>
                                To make the generation process quicker, I wanted to build a system that could "look ahead" for an optimal placement instead of just placing rooms until something works.
                                So, I built a process that would behave as follows. First, pick a random position in the Building's space and place a <i>fake</i> room region. 
                                Using this room region as the starting point, recursively attempt to place the next <i>fake</i> region and divide it into rooms. This new room region is now the starting point.
                                After the placement of all room regions have been visited, the generation system now knows where the optimal placements are for the starting room region and can quickly generate random building layouts.
                                This same behavior would also behave with multiple floors as well.                 
                                </p>
                              </div>
                              <div class="text">
                                <p>
                                Since this behavior didn't technically require Unity to perform, I was able to run the calculations on a separate thread so Unity could still perform in runtime. This made it so we could easily integrate loading screens and other ways to keep the player entertained while the generator was running.
                                </p>
                              </div>
                              <div class="text">
                                <p>
                                Here's the final core loop of the generator. I wanted to make sure each step was organized and clear, especially when debugging.
                                </p>
                              </div>
                                <div class="code">
                              <pre><code class="language-csharp">
void UpdateGenerator()
{
    switch (GENERATION_PHASE)
    {
        case GenerationPhase.Starting:

            SeedManager.SetupSeed(seed);
            LoadBlueprints();
            CreateStructureParents();
            InitializeStructureTileMap();
            SetupExteriorWalls();
            InteriorRegionGenerationThread = new Thread(AttemptToGenerateInteriorRegionsAndRooms);
            InteriorRegionGenerationThread.Start();
            GENERATION_PHASE = GenerationPhase.RoomsAndRegions;
            break;
        case GenerationPhase.RoomsAndRegions:
            if (!InteriorRegionGenerationThread.IsAlive)
            {
                HallGenerationThread = new Thread(AttemptToGenerateHalls);
                HallGenerationThread.Start();
                GENERATION_PHASE = GenerationPhase.Halls;
            }
            break;
        case GenerationPhase.Halls:
            if (!HallGenerationThread.IsAlive)
            {
                CalculateRoomDoors();
                RebuildExteriorWalls();
                GENERATION_PHASE = GenerationPhase.OutsideRoomsAndRegions;
            }
            break;
        case GenerationPhase.OutsideRoomsAndRegions:
            if (!ExteriorRegionGenerationThread.IsAlive)
                GENERATION_PHASE = GenerationPhase.Completing;
            break;
        case GenerationPhase.Completing:

            GenerateWalls();
            MergeIntersectingWalls();
            MergeIntersectingWalls();
            SetupWallReferences();
            GenerateFloors();
            GenerateCeilings();
            CreateRoomZones();
            SpawnHallFurniture();
            SpawnRoomFurniture();
            SpawnItems();
            PerformStaticBatches();
            CleanUp();           
            break;
        default:
            break;
    }
                                                            </code></pre>
                            </div>

                          </div>                      
                        </div>
  
                    
                    </div>

                    
                    <div class="text">
                        <p>Here's a little demonstration of the generator in action. In this example, it's generating a school</i></p>
                    </div>
                    <div class="video-container">

                    <video controls>
                        <source src="Video Clips/mulligan_clip.mp4" type="video/mp4">
                      </video> 
                    </div>

                    <div class="text">
                        <p>With the generation system, I also knew I wanted to create an easy way to streamline room blueprints, especially for level designers. 
                            So I decided to build an in-house room editor tool that would integrate directly into the generation system. It ended up being a really fun tool to use.
                            All of the blueprints would save as JSON files and would be loaded into RoomBlueprint.cs Scriptable Objects which each Building blueprint would contain.
                            With this tool we could create as many layouts as we wanted, and they would all be compatible with the level generator. Here's a clip of it in action:
                        </p>
                    </div>
                    <div class="video-container">

                        <video controls>
                            <source src="Video Clips/mulligan_roomeditor.mp4" type="video/mp4">
                          </video> 
                        </div>

                        <div class="text">
                            <p><i>80LV</i> also wrote an article about the tool which I was really excited to see: <a href="https://80.lv/articles/a-neat-sims-like-room-editor-made-for-a-horror-game/" target="_blank">Editor Article</a>
                            </p>
                        </div>
                    </div>
                    
            

                  

                </div>
              
			</div>

            
			<div class="overlay"></div>
			<div class="reveal"></div>
			<div class="line"></div>
		</section>
        <section class="project">
			<div class="project-info">
                <div class="title-year-container">
                    <h2>Aseprite 3D Renderer Tool</h2>
                    <h3 class="year">2023</h3>
                  </div>
				<h3><b>Skills/Software Used:</b> <i>Visual Studio 2022, C#, 3D Mathematics, Lua</i></h3>
			</div>
			<div class="details">

                <p>The <b>Aseprite 3D Renderer Tool</b> is a plugin I'm currently developing for a popular 2D pixel art program called Aseprite. 
                    It allows users to import 3D model files in the 2D program, granting a new 2D asset pipeline for developers.
                    With the plugin, they can use the models as art references or to export assets directly as 2D animations/sprite sheets.
                    The tool also includes a custom animation system, customizable render settings, and support for skinned meshes from .FBX files,
                </p>
            
           
                <div class="video-container">

                    <video controls>
                        <source src="Video Clips/Aseprite_1.mp4" type="video/mp4">
                      </video> 
                    </div>

                    <div class="video-container">

                        <video controls>
                            <source src="Video Clips/Aseprite_2.mp4" type="video/mp4">
                          </video> 
                        </div>

                <h3><b>Work Done</b></h3>
                <ul>
                    <li>Built multithreaded 3D rendering system into Aseprite viewport for artists to integrate into their own workflows.</li>
                        <li>Designed parsing systems for 3D model files .obj and .fbx.</li>
                            <li>Engineered animation systems that process skinned mesh data from 3D model files.</li>
                                <li>Developed shading systems with customizable render integrations (dithering, textures, specular, normal maps)</li>
                </ul>
                 
                    </div>
                    
            

                  

                </div>
              
			</div>

            
			<div class="overlay"></div>
			<div class="reveal"></div>
			<div class="line"></div>
		</section>
        <section class="project">
			<div class="project-info">
                <div class="title-year-container">
                    <h2>Anekom Game Engine</h2>
                    <h3 class="year">2019-2020</h3>
                  </div>
				<h3><b>Skills/Software Used:</b> <i>Visual Studio 2022, C++, OpenGL</i></h3>
			</div>
			<div class="details">

                <p><b>Anekom Game Engine</b> is a fully-fledged game engine I developed during my time at DePaul University. 
                    Each student was given a specific element of a game engine to focus on, and I decided to make an in-depth level editor and script serialization system.
                    I also integrated an A* pathfinding system, which I ended up using for a demo Tank game. The engine features everything from OpenGL rendering, collision checking, game object management, and an in-depth transform system.</p>
            

         
      

                <h3><b>Work Done</b></h3>
                <ul>
                    <li>Integrated OpenGL rendering, texture mapping, and 3D model importing.</li>
                        <li>Built custom module system for modifying game object attributes.</li>
                                <li>Created full level editor with seamless game object transformation editing.</li>
                                   <li>Added Game Object management and registration with memory recycling systems.</li>
                                        <li>Engineered collision and A* pathfinding systems.</li>
                </ul>
           
                <div class="text">
                    <p>
                    Here was my final sprint recording where I explain the game engine in full! Feel free to hop around it and check out the features of the engine. The scene editor it demonstrated at 37:00.
                    </p>
                  </div>
                  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/TUs6WglsSTQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen style="height: 600px;"></iframe>

                
                    </div>
                    
            

                  

                </div>
              
			</div>

            
			<div class="overlay"></div>
			<div class="reveal"></div>
			<div class="line"></div>
		</section>
       
	</main>
	</main>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script type="text/javascript" src="slick/slick.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.js"></script>

    <script type="text/javascript">
      $(document).ready(function(){
        $('.slideshow').slick({
            infinite: true,
            dots: true,
            centerMode: false,
            variableWidth: false,
            speed: 400,

        });
      });
    </script>

	<script src="script.js"></script>

</body>
</html>
